<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>S32DS集成MCAL</title>
    <link href="/posts/f2c01706/"/>
    <url>/posts/f2c01706/</url>
    
    <content type="html"><![CDATA[<blockquote><p>简介：MCU 为 NXP-S32K344；RTD MCAL 版本为 <code>SW32K3_RTD_R21-11_4.0.0_HF_02</code> ；S32DS 3.5；EB Tresos 29.0</p></blockquote><h2 id="1-安装-MCAL"><a href="#1-安装-MCAL" class="headerlink" title="1 安装 MCAL"></a>1 安装 MCAL</h2><p>下载此版本的 RTD：<code>S32K3_S32M27x Real-Time Drivers AUTOSAR R21-11 Version 4.0.0 HF02</code></p><p><img src="/posts/f2c01706/4155c4d63fbc44a1ae44fb0a34f2e5c7_MD5.jpeg"></p><p>下载并安装此版本的 MCAL：</p><p><img src="/posts/f2c01706/556b712927fb214779e0a7dc24fba1c5_MD5.jpeg"></p><p>这里，我的安装后的 MCAL 的路径如下：</p><p><img src="/posts/f2c01706/bd995acaed19722bd0a14013bc91b6ab_MD5.jpeg"></p><h3 id="1-1-MCAL-的配置"><a href="#1-1-MCAL-的配置" class="headerlink" title="1.1 MCAL 的配置"></a>1.1 MCAL 的配置</h3><p>复制 MCAL 路径下的<em>所有模块</em>到一个<em>临时文件夹</em>中进行下一步处理，我这里就是复制 <code>D:\NXP\exe\SW32K3_RTD_R21-11_4.0.0_HF_02\eclipse\plugins</code> 下的所有<strong>文件夹</strong>到一个临时文件夹 <code>plugins_handle</code> 中：</p><p><img src="/posts/f2c01706/99ed706fdea36147ede5f17e9bf22459_MD5.jpeg"></p><p>对各模块的文件夹进行重命名，更好看些，使用如下 python 脚本进行重命名：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 获取当前路径</span><br>current_path = os.getcwd()<br><br><span class="hljs-comment"># 遍历一级文件夹</span><br><span class="hljs-keyword">for</span> folder <span class="hljs-keyword">in</span> os.listdir(current_path):<br>    <span class="hljs-keyword">if</span> os.path.isdir(folder):<br>        <span class="hljs-comment"># 获取新名称，即第一个下划线之前的内容</span><br>        first_part = folder.split(<span class="hljs-string">&#x27;_&#x27;</span>)[<span class="hljs-number">0</span>]<br>        <br>        <span class="hljs-comment"># 检查是否需要处理</span><br>        <span class="hljs-keyword">if</span> first_part != <span class="hljs-string">&quot;Mem&quot;</span>:<br>            new_name = first_part<br>            <br>            <span class="hljs-comment"># 检查新名称是否已存在</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(new_name):<br>                os.rename(folder, new_name)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文件夹名称已更新。&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>使用方法：在临时文件夹（D:\NXP\exe\plugins_handle）中新建并复制上面👆代码到 <code>rename.py</code> 中，然后运行</p></blockquote><p><img src="/posts/f2c01706/e2d1a0515f300b839b46be4e7bf066be_MD5.jpeg"></p><p>上面这三个文件夹需要手动重命名为如下（脚本已自动忽略处理这三个文件夹）：</p><p><img src="/posts/f2c01706/b46beae0efcfc3a0c8a55c41c0545fcb_MD5.jpeg"></p><p>接下来，删除每个模块文件夹中除了 src 和 include 之外的所有文件，其中 BaseNXP、Platform 这两个模块需要手动处理，使用如下脚本进行删除：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> shutil<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">clean_directories</span>(<span class="hljs-params">base_path</span>):<br>    <span class="hljs-comment"># 列出当前路径下的一级文件夹</span><br>    <span class="hljs-keyword">for</span> folder <span class="hljs-keyword">in</span> os.listdir(base_path):<br>        folder_path = os.path.join(base_path, folder)<br><br>        <span class="hljs-comment"># 只处理文件夹，且不处理“BaseNXP.Base”和“Platform”</span><br>        <span class="hljs-keyword">if</span> os.path.isdir(folder_path) <span class="hljs-keyword">and</span> folder <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;BaseNXP&quot;</span>, <span class="hljs-string">&quot;Platform&quot;</span>, <span class="hljs-string">&quot;Base&quot;</span>]:<br>            <span class="hljs-comment"># 遍历文件夹中的内容</span><br>            <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> os.listdir(folder_path):<br>                item_path = os.path.join(folder_path, item)<br><br>                <span class="hljs-comment"># 检查是否是文件夹，且不是“src”或“include”</span><br>                <span class="hljs-keyword">if</span> os.path.isdir(item_path) <span class="hljs-keyword">and</span> item <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;src&quot;</span>, <span class="hljs-string">&quot;include&quot;</span>]:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;删除文件夹: <span class="hljs-subst">&#123;item_path&#125;</span>&quot;</span>)<br>                    shutil.rmtree(item_path)  <span class="hljs-comment"># 删除文件夹</span><br><br>                <span class="hljs-comment"># 检查是否是文件</span><br>                <span class="hljs-keyword">elif</span> os.path.isfile(item_path):<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;删除文件: <span class="hljs-subst">&#123;item_path&#125;</span>&quot;</span>)<br>                    os.remove(item_path)  <span class="hljs-comment"># 删除文件</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    current_path = os.getcwd()  <span class="hljs-comment"># 获取当前路径</span><br>    clean_directories(current_path)<br></code></pre></td></tr></table></figure><p>脚本已忽略处理 BaseNXP、Platform 模块，需要手动修改：</p><p>BaseNXP 保留如下三个文件夹：</p><p><img src="/posts/f2c01706/39692b62b1d6014ea21b55133a458b6c_MD5.jpeg"></p><p>Platform 保留如下：</p><p><img src="/posts/f2c01706/8f0e11256e196310b89e5946fce79133_MD5.jpeg"></p><blockquote><p>进一步，其中 Platform&#x2F;build_files 下仅保留 gcc；Platform&#x2F;startup&#x2F;src&#x2F;m7 下仅保留 gcc、exceptions.c、startup.c</p></blockquote><p>然后，导出各模块的 include 路径，使用如下脚本：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 示例路径，保留&quot;&quot;</span><br>template_path = <span class="hljs-string">&#x27;&quot;$&#123;workspace_loc:/$&#123;ProjName&#125;/MCAL/DIR/include&#125;&quot;&#x27;</span><br><br><span class="hljs-comment"># 当前路径</span><br>current_path = os.getcwd()<br><br><span class="hljs-comment"># 创建一个列表来存储所有路径</span><br>paths = []<br><br><span class="hljs-comment"># 遍历当前路径下的一级文件夹</span><br><span class="hljs-keyword">for</span> folder <span class="hljs-keyword">in</span> os.listdir(current_path):<br>    folder_path = os.path.join(current_path, folder)<br>    <span class="hljs-comment"># 检查是否为文件夹</span><br>    <span class="hljs-keyword">if</span> os.path.isdir(folder_path):<br>        <span class="hljs-comment"># 检查是否存在 &#x27;include&#x27; 文件夹</span><br>        include_folder = os.path.join(folder_path, <span class="hljs-string">&#x27;include&#x27;</span>)<br>        <span class="hljs-keyword">if</span> os.path.exists(include_folder):<br>            <span class="hljs-comment"># 将 DIR 替换为当前文件夹名称，且保留&quot;&quot;</span><br>            new_path = template_path.replace(<span class="hljs-string">&#x27;DIR&#x27;</span>, folder)<br>            <span class="hljs-comment"># 添加到路径列表</span><br>            paths.append(new_path)<br><br><span class="hljs-comment"># 在列表开头插入三个新路径</span><br>paths.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;&quot;$&#123;ProjDirPath&#125;/include&quot;&#x27;</span>)<br>paths.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;&quot;$&#123;workspace_loc:/$&#123;ProjName&#125;/MCAL/Platform/startup/include&#125;&quot;&#x27;</span>)<br>paths.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;&quot;$&#123;workspace_loc:/$&#123;ProjName&#125;/MCAL/BaseNXP/header&#125;&quot;&#x27;</span>)<br>paths.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;&quot;$&#123;workspace_loc:/$&#123;ProjName&#125;/generate/include&#125;&quot;&#x27;</span>)<br><br><span class="hljs-comment"># 打开 path.txt 文件用于写入</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(os.path.join(current_path, <span class="hljs-string">&#x27;path.txt&#x27;</span>), <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> output_file:<br>    <span class="hljs-comment"># 写入所有路径到 path.txt</span><br>    <span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> paths:<br>        output_file.write(path + <span class="hljs-string">&#x27;\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;路径已写入到 path.txt 文件。&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>此脚本会在当前运行路径下生成 path.txt 存放各模块的 include 路径</p></blockquote><h2 id="2-S32DS-Project"><a href="#2-S32DS-Project" class="headerlink" title="2 S32DS Project"></a>2 S32DS Project</h2><h3 id="2-1-新建-Project"><a href="#2-1-新建-Project" class="headerlink" title="2.1 新建 Project"></a>2.1 新建 Project</h3><p>新建一个空项目：</p><p><img src="/posts/f2c01706/85fd1f90e5a73f9636adb37efd36d5ef_MD5.jpeg"></p><p><img src="/posts/f2c01706/0ba7ac5909654472258ec19c52927d25_MD5.jpeg"></p><p><img src="/posts/f2c01706/7a3ea107f0a98222751976c76f42dc48_MD5.jpeg"></p><p>删除项目中的这三个文件夹：</p><p><img src="/posts/f2c01706/3232a9cea904dfb8f8db64c2d53f9028_MD5.jpeg"></p><p>新建这三个文件夹：</p><p><img src="/posts/f2c01706/b0105a880529ebe81d098669d36036c1_MD5.jpeg"></p><blockquote><p>其中，MCAL 用来存放 MCAL 各模块驱动的源码；generate 用来存放 EB_Tresos 工具生成的代码；Tresos_Project 是 EB 项目的路径</p></blockquote><p>将这三个文件夹添加到编译路径里：</p><p><img src="/posts/f2c01706/87b67841a86f354cebfef69122db5ae4_MD5.jpeg"></p><p>复制临时文件夹中所有模块的源码到 S32DS 项目的 MCAL 文件夹中：</p><p><img src="/posts/f2c01706/29a2cafd2ad5e161e46e260a5179032a_MD5.jpeg"></p><h3 id="2-2-配置-Project"><a href="#2-2-配置-Project" class="headerlink" title="2.2 配置 Project"></a>2.2 配置 Project</h3><p>右键项目选择 Properties：</p><p><img src="/posts/f2c01706/4636104653d97a00e58d02bc5133d149_MD5.jpeg"></p><p>添加如下定义：</p><p><img src="/posts/f2c01706/5c6d87192e721d12df16dcf667d9dc24_MD5.jpeg"></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs txt">S32K3XX<br>AUTOSAR_OS_NOT_USE<br>S32K344<br>GCC<br>USE_SW_VECTOR_MODE<br>D_CACHE_ENABLE<br>I_CACHE_ENABLE<br>ENABLE_FPU<br></code></pre></td></tr></table></figure><p>添加头文件，将临时文件夹下 path.txt 中的所有内容复制到此处：</p><p><img src="/posts/f2c01706/a550ed853da91e9d6ba6d10e92f08195_MD5.jpeg"></p><p>选择优化选项：</p><p><img src="/posts/f2c01706/df1004391b20d0dd0ba5f86819474466_MD5.jpeg"></p><p><code>-fno-short-enums -funsigned-char -fomit-frame-pointer -fstack-usage</code></p><p>配置链接器：</p><p><img src="/posts/f2c01706/605b1abf62a5a1d19ee3518229540bd9_MD5.jpeg"></p><p><code>&quot;$&#123;workspace_loc:/$&#123;ProjName&#125;/MCAL/Platform/build_files/gcc/linker_flash_s32k344.ld&#125;&quot;</code></p><h2 id="3-EB-Tresos-Project"><a href="#3-EB-Tresos-Project" class="headerlink" title="3 EB-Tresos Project"></a>3 EB-Tresos Project</h2><p>选择新建项目：</p><p><img src="/posts/f2c01706/491a7794751838ebf8e7e059ccd2b8f2_MD5.jpeg"></p><p><img src="/posts/f2c01706/2a7b53106d6f50ad85879e59b8094e6e_MD5.jpeg"></p><p><img src="/posts/f2c01706/88c9a84e08c1f09eaec15d5bdaab8ef3_MD5.jpeg"></p><p>以官方 Dio 点灯为例，添加如下模块（具体项目中使用到了哪些模块就添加哪些模块）<br>参考官方示例代码，在已安装的 MCAL 路径下: <code>SW32K3_RTD_R21-11_4.0.0_HF_02\eclipse\plugins\Dio_TS_T40D34M40I0R0\examples\EBT\S32K3XX\Dio_Example_S32K344\TresosProject\Dio_Example_S32K344</code></p><p><img src="/posts/f2c01706/15a69ffd7b1ed7c9d2383e44e2d1bf61_MD5.jpeg"></p><p>复制 <code>SW32K3_RTD_R21-11_4.0.0_HF_02\eclipse\plugins\Dio_TS_T40D34M40I0R0\examples\EBT\S32K3XX\Dio_Example_S32K344\TresosProject\Dio_Example_S32K344</code> 路径下 config 文件夹下的所有文件到 S32DS 项目 Tresos_Project 下的 config 中（覆盖原文件）</p><p>然后在 EB 中生成代码：</p><p><img src="/posts/f2c01706/16333f2b8d669a8b7f798f9ec8ead34f_MD5.jpeg"></p><p>此时，刷新 S32DS 后 generate 下就有生成的代码了：</p><p><img src="/posts/f2c01706/c4b6688882afeda620e3b9aa1d617b9a_MD5.jpeg"></p><h2 id="4-编译"><a href="#4-编译" class="headerlink" title="4 编译"></a>4 编译</h2><p>复制 Dio 示例代码 <code>D:\NXP\exe\SW32K3_RTD_R21-11_4.0.0_HF_02\eclipse\plugins\Dio_TS_T40D34M40I0R0\examples\EBT\S32K3XX\Dio_Example_S32K344\src</code> 下的 main.c 替换 S32DS 项目下 src 中的 mian.c ；<br>并且注释掉 <code>#include &quot;check_example.h&quot;</code>、<code>Exit_Example(TRUE);</code></p><p><img src="/posts/f2c01706/3a907d3bf486b795032c937036e248e3_MD5.jpeg"></p><p><img src="/posts/f2c01706/f1af8bdd5b158de26f2ec4216641dd09_MD5.jpeg"></p><p>先将 S32DS 项目下 MCAL 中的所有模块移除编译路径：</p><p><img src="/posts/f2c01706/99dd74ca2831cc07b9196a1828b51812_MD5.jpeg"></p><p>根据 Dio 官方示例添加所需的模块到编译路径：</p><p><img src="/posts/f2c01706/15a69ffd7b1ed7c9d2383e44e2d1bf61_MD5.jpeg"></p><p><img src="/posts/f2c01706/ce8419e389353a0f21bcf9b4166f2dec_MD5.jpeg"></p><p>接下来，就是编译处理报错：</p><p><img src="/posts/f2c01706/53876be4657bbf83688faa00a681ccab_MD5.jpeg"></p><p>此处报错说找不到这个 <code>SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01</code></p><p>为了方便搜索，用 VSCode 打开这个 S32DS 项目：</p><p><img src="/posts/f2c01706/406ea2deef38c6b05d20b6b32972ee3f_MD5.jpeg"></p><p>在 VSCode 中搜索 <code>SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01</code>：</p><p><img src="/posts/f2c01706/bf985a4025126251509133e15280c70e_MD5.jpeg"></p><p>可以看到，<code>MCAL\Dio\src\Siul2_Dio_Ip.c</code> 调用了 <code>SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01</code> 函数，其函数的定义是在 MCAL 的 Rte 模块中。那么就添加 MCAL&#x2F;Rte 到编译路径中：</p><p><img src="/posts/f2c01706/8c34ca8429429e7259bee73ee5d19fc2_MD5.jpeg"></p><p>再次编译：</p><p><img src="/posts/f2c01706/3a55d3dfb95fa05fb10f53db3cca6bbd_MD5.jpeg"></p><p>显然，需要添加 MCAL&#x2F;Det 模块到编译路径中：</p><p><img src="/posts/f2c01706/078e0c3678b8e1452593326966d0ca07_MD5.jpeg"></p><p>再次编译，没有错误了：</p><p><img src="/posts/f2c01706/a07081cb66de3d14da6f133dbdfb2baf_MD5.jpeg"></p><p>烧录测试后，LED 正常闪烁！</p>]]></content>
    
    
    <categories>
      
      <category>MCU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>S32DS</tag>
      
      <tag>EB_Tresos</tag>
      
      <tag>MCAL</tag>
      
      <tag>Autosar</tag>
      
      <tag>S32K344</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派5-LED-Platform驱动</title>
    <link href="/posts/bcdde5bf/"/>
    <url>/posts/bcdde5bf/</url>
    
    <content type="html"><![CDATA[<h2 id="1-选择-GPIO-引脚"><a href="#1-选择-GPIO-引脚" class="headerlink" title="1 选择 GPIO 引脚"></a>1 选择 GPIO 引脚</h2><p>在树莓派的扩展口中以 <a href="https://pinout.xyz/pinout/pin11_gpio17/">GPIO17</a> 为例，点亮 LED 灯。</p><p><img src="/posts/bcdde5bf/686d5a50e65e8be9d3068fa4c00c26cf_MD5.jpeg"></p><p>GPIO17 介绍：</p><p><img src="/posts/bcdde5bf/a98d4024377461eb5bd55f6bcb4e7248_MD5.jpeg"></p><h2 id="2-配置设备树-dts"><a href="#2-配置设备树-dts" class="headerlink" title="2 配置设备树 dts"></a>2 配置设备树 dts</h2><p>树莓派5 的设备树文件是 <code>arch/arm64/boot/dts/broadcom/bcm2712-rpi-5-b.dts</code> :</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;arm/broadcom/bcm2712-rpi-5-b.dts&quot;</span></span><br></code></pre></td></tr></table></figure><p>因为包含了 arm 下的 dts，所以修改 <code>arch/arm/boot/dts/broadcom/bcm2712-rpi-5-b.dts</code>，添加 jw_led 节点：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">/</span> <span class="hljs-punctuation">&#123;</span><br>...<br><span class="hljs-symbol">led:</span> <span class="hljs-title class_">leds</span> <span class="hljs-punctuation">&#123;</span><br>...<br><span class="hljs-punctuation">&#125;;</span><br><span class="hljs-comment">//在此处添加 jw_led 节点</span><br><span class="hljs-symbol">jw_led:</span> <span class="hljs-title class_">jw_gpio17</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-punctuation">&#125;;</span><br>...<br><span class="hljs-punctuation">&#125;;</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rp1.dtsi&quot;</span></span><br>...<br><span class="hljs-symbol">gpio:</span> <span class="hljs-variable">&amp;rp1_gpio</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">status</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;okay&quot;</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;;</span><br><span class="hljs-comment">//在此处引用修改 jw_led 节点</span><br><span class="hljs-variable">&amp;jw_led</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jw,jwled369&quot;</span><span class="hljs-punctuation">;</span><br><span class="hljs-attr">led-gpios</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;gpio</span> <span class="hljs-number">17</span> GPIO_ACTIVE_HIGH&gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>关于 rp1 芯片阅读官方的数据手册。</p><h2 id="3-编写-Platform-驱动"><a href="#3-编写-Platform-驱动" class="headerlink" title="3 编写 Platform 驱动"></a>3 编写 Platform 驱动</h2><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio/consumer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/platform_device.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DRIVER_NAME <span class="hljs-string">&quot;jw_led&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">jw_led</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpio_desc</span> *<span class="hljs-title">gpio</span>;</span><br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jw_led_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">jw_led</span> *<span class="hljs-title">led</span>;</span><br><br>    led = devm_kzalloc(&amp;pdev-&gt;dev, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> jw_led), GFP_KERNEL);<br>    <span class="hljs-keyword">if</span> (!led)<br>        <span class="hljs-keyword">return</span> -ENOMEM;<br><br>    platform_set_drvdata(pdev, led);<br><br>    led-&gt;gpio = devm_gpiod_get_index(&amp;pdev-&gt;dev, <span class="hljs-string">&quot;led&quot;</span>, <span class="hljs-number">0</span>, GPIOD_OUT_LOW);<br>    <span class="hljs-keyword">if</span> (IS_ERR(led-&gt;gpio)) &#123;<br>        dev_err(&amp;pdev-&gt;dev, <span class="hljs-string">&quot;Failed to get jw_led/led-gpios property: %ld\n&quot;</span>,<br>                PTR_ERR(led-&gt;gpio));<br>        <span class="hljs-keyword">return</span> PTR_ERR(led-&gt;gpio);<br>    &#125;<br><br>    <span class="hljs-comment">/* 在这里可以添加其他代码来控制 GPIO17 */</span><br>    <span class="hljs-comment">// gpiod_set_value(led-&gt;gpio, 1);</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">jw_led_of_match</span>[] =</span> &#123;<br>    &#123; .compatible = <span class="hljs-string">&quot;jw,jwled369&quot;</span>, &#125;,<br>    &#123; <span class="hljs-comment">/* end of list */</span> &#125;,<br>&#125;;<br>MODULE_DEVICE_TABLE(of, jw_led_of_match);<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">jw_led_driver</span> =</span> &#123;<br>    .probe = jw_led_probe,<br>    .driver = &#123;<br>        .name = DRIVER_NAME,<br>        .of_match_table = jw_led_of_match,<br>    &#125;,<br>&#125;;<br>module_platform_driver(jw_led_driver);<br><br>MODULE_AUTHOR(<span class="hljs-string">&quot;jw.lee&quot;</span>);<br>MODULE_DESCRIPTION(<span class="hljs-string">&quot;LED driver&quot;</span>);<br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL v2&quot;</span>);<br></code></pre></td></tr></table></figure><p>最后，编译成模块在树莓派上 insmod 即可。</p>]]></content>
    
    
    <categories>
      
      <category>树莓派驱动</category>
      
    </categories>
    
    
    <tags>
      
      <tag>platform</tag>
      
      <tag>gpio</tag>
      
      <tag>dts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vscode、Clangd、RemoteSSH——环境配置</title>
    <link href="/posts/af2bf757/"/>
    <url>/posts/af2bf757/</url>
    
    <content type="html"><![CDATA[<blockquote><p>使用场景：Windows 端 Vscode 使用 RemoteSSH 插件远程连接到 fedora 系统，并且项目源码是在 fedora 上。</p></blockquote><h2 id="1-安装-bear"><a href="#1-安装-bear" class="headerlink" title="1 安装 bear"></a>1 安装 bear</h2><p><code>sudo dnf install bear</code></p><p><img src="/posts/af2bf757/7c7eb2ee8ae3d4cb5f21a19fc1085371_MD5.jpeg"></p><h2 id="2-安装-clang、clangd"><a href="#2-安装-clang、clangd" class="headerlink" title="2 安装 clang、clangd"></a>2 安装 clang、clangd</h2><p><code>sudo dnf install clang</code></p><p><code>sudo dnf install clang-tools-extra</code></p><p><img src="/posts/af2bf757/9b3d43fdbf79395f56ea1a63d0976da1_MD5.jpeg"></p><h2 id="3-配置-VScode-Clangd-插件"><a href="#3-配置-VScode-Clangd-插件" class="headerlink" title="3 配置 VScode Clangd 插件"></a>3 配置 VScode Clangd 插件</h2><blockquote><p>需要先将 VScode 中的所有 C&#x2F;C++ 插件禁用或卸载</p></blockquote><p>在 VScode 的插件里面搜索 “Clangd” 并且安装。</p><p>安装完毕后，打开 VScode 设置：</p><p><img src="/posts/af2bf757/911d5ef43a63ee4d32ac535e675f78c1_MD5.jpeg"></p><p>我是在远程中设置的，打开远程的 settings. json 文件，配置如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;clangd.path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/clangd&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;clangd.arguments&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;--background-index&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;--compile-commands-dir=/home/jw/develop/linux&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;-j=4&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;--query-driver=/usr/bin/aarch64-linux-gnu-gcc&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;--clang-tidy&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;--clang-tidy-checks=performance-*,bugprone-*&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;--all-scopes-completion&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;--completion-style=detailed&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;--header-insertion=iwyu&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;--pch-storage=disk&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;--compile-commands-dir=$&#123;workspaceFolder&#125;&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;--background-index&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;--completion-style=detailed&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;--header-insertion=never&quot;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;clangd.fallbackFlags&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;-I/home/jw/develop/linux/include&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;-I/home/jw/develop/linux/arch/arm64/include&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;-I/home/jw/develop/linux/arch/arm64/include/generated/&quot;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>“clangd.path” 使用 <code>which clangd</code> 命令查看：<img src="/posts/af2bf757/878188bbfc108b4d84d3c3e79ceded27_MD5.jpeg"></li><li>“clangd.arguments” 的 –compile-commands-dir 填你的项目源码根目录</li><li>“clangd.arguments” 的 –query-driver 填交叉编译器路径</li><li>“clangd.fallbackFlags” 中 <code>/home/jw/develop/linux</code> 替换成你的项目路径</li><li>“clangd.fallbackFlags” 中 <code>arch/arm64/include</code> 、<code>arch/arm64/include/generated/</code> 使用 arm64 架构，根据自己的开发板架构来</li></ul><h2 id="4-编译项目生成-compile-commands-json-文件"><a href="#4-编译项目生成-compile-commands-json-文件" class="headerlink" title="4 编译项目生成 compile_commands.json 文件"></a>4 编译项目生成 <code>compile_commands.json</code> 文件</h2><p>重新编译 kernel 镜像，先 clean 项目再编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">make distclean<br>make bcm2712_defconfig    //根据你的开发板而定<br>bear -- make Image -j8    //Image、zImage还是uImage根据你的开发板而定<br></code></pre></td></tr></table></figure><p>编译完后会在项目根目录下生成 <code>compile_commands.json</code> 文件：</p><p><img src="/posts/af2bf757/e66215266218dbfc3e0ae4402749022f_MD5.jpeg"></p><p>将所有的 <code>/usr/bin/gcc</code> 替换成你的交叉编译器，我的是 <code>/usr/bin/aarch64-linux-gnu-gcc</code> VIM 中使用 <code>:%s#/usr/bin/gcc#/usr/bin/aarch64-linux-gnu-gcc#g</code> 命令替换。</p><h3 id="4-1-创建-clangd-文件"><a href="#4-1-创建-clangd-文件" class="headerlink" title="4.1 创建 .clangd 文件"></a>4.1 创建 <code>.clangd</code> 文件</h3><p>在项目根目录下创建 <code>.clangd</code> 文件，内容如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">CompileFlags:<br>    Add:<br>        [-I, &quot;/usr/include&quot;]<br>    Remove: <br>        [<br>            -fno-allow-store-data-races,<br>            -fconserve-stack,<br>            -mabi=lp64<br>        ]<br></code></pre></td></tr></table></figure><p>其中的 Remove 是为了忽略 gcc 和 clang 编译器不兼容而出现的错误。</p><h2 id="5-VScode-打开项目"><a href="#5-VScode-打开项目" class="headerlink" title="5 VScode 打开项目"></a>5 VScode 打开项目</h2><p>使用 VScode 打开项目：</p><p><img src="/posts/af2bf757/77b2fe94fef24678a77591234969a3f5_MD5.jpeg"></p><p>ok，此时就可以代码提示和补全了！</p><h3 id="5-1-处理一些问题"><a href="#5-1-处理一些问题" class="headerlink" title="5.1 处理一些问题"></a>5.1 处理一些问题</h3><p>如果配置后不起效，可以在 clangd 的 log 中查看哪里的问题：</p><p><img src="/posts/af2bf757/f195d476a19cf7c2c9d44011984dc37f_MD5.jpeg"></p><p><img src="/posts/af2bf757/42df14c724748d944e53139e38785f60_MD5.jpeg"></p><p>具体的问题可以在网上搜索下。</p><blockquote><p>参考文章：<a href="https://blog.csdn.net/Telly_/article/details/134289358">VSCode 使用 clangd 构建 Linux 驱动开发环境</a>、<a href="https://blog.csdn.net/zhanzheng520/article/details/135103043">clangd: Couldn‘t build compiler instance</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>DIY</category>
      
    </categories>
    
    
    <tags>
      
      <tag>clangd</tag>
      
      <tag>lsp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc学习笔记2</title>
    <link href="/posts/d7382070/"/>
    <url>/posts/d7382070/</url>
    
    <content type="html"><![CDATA[<p>待更新</p>]]></content>
    
    
    <categories>
      
      <category>gcc学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GNU</tag>
      
      <tag>GCC</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用软件安装配置</title>
    <link href="/posts/28f0e3d2/"/>
    <url>/posts/28f0e3d2/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Node-js-安装配置"><a href="#1-Node-js-安装配置" class="headerlink" title="1 Node. js 安装配置"></a>1 Node. js 安装配置</h2><ol><li>从 node. js 官网下载 Linux 版的 tar. xz 文件</li><li>解压 <code>tar -xJf node-v20.10.0-linux-x64.tar.xz</code></li><li>重命名 <code>mv node-v20.10.0-linux-x64 node_js</code></li><li>移动到 <code>/usr/local</code> 路径下 <code>sudo mv ~/Downloads/node_js /usr/local/</code></li><li>建立软链接：<ul><li><code>sudo ln -s /usr/local/node_js/bin/node /usr/local/bin/</code></li><li><code>sudo ln -s /usr/local/node_js/bin/npm /usr/local/bin/</code></li></ul></li><li>编辑环境变量：<br>在 <code>/etc/profile</code> 末尾添加：<ul><li><code>export NODE_HOME=/usr/local/node_js</code></li><li><code>export PATH=$NODE_HOME/bin:$PATH</code></li></ul></li><li>刷新环境变量 <code>source /etc/profile</code></li><li>换淘宝源 <code>npm config set registry https://registry.npmmirror.com</code> 或腾讯源 <code>npm config set registry http://mirrors.cloud.tencent.com/npm</code></li></ol><h2 id="2-Fedora-配置"><a href="#2-Fedora-配置" class="headerlink" title="2 Fedora 配置"></a>2 Fedora 配置</h2><h3 id="2-1-Fedora-换源"><a href="#2-1-Fedora-换源" class="headerlink" title="2.1 Fedora 换源"></a>2.1 Fedora 换源</h3><ul><li><code>sudo mkdir -p /etc/yum.repos.d/backup</code></li><li><code>sudo cp -rfp /etc/yum.repos.d/fedora.repo /etc/yum.repos.d/fedora-updates.repo /etc/yum.repos.d/backup</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo sed -e &#x27;s|^metalink=|#metalink=|g&#x27; \<br>         -e &#x27;s|^#baseurl=http://download.example/pub/fedora/linux|baseurl=https://mirrors.ustc.edu.cn/fedora|g&#x27; \<br>         -i.bak \<br>         /etc/yum.repos.d/fedora.repo \<br>         /etc/yum.repos.d/fedora-updates.repo<br></code></pre></td></tr></table></figure><ul><li><code>sudo dnf clean all</code></li><li><code>sudo dnf makecache</code></li></ul><h3 id="2-2-Fedora-换-RPM-Fusion-源"><a href="#2-2-Fedora-换-RPM-Fusion-源" class="headerlink" title="2.2 Fedora 换 RPM Fusion 源"></a>2.2 Fedora 换 RPM Fusion 源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo dnf install https://mirrors.ustc.edu.cn/rpmfusion/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.ustc.edu.cn/rpmfusion/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm<br></code></pre></td></tr></table></figure><h3 id="2-3-Gnome-桌面优化"><a href="#2-3-Gnome-桌面优化" class="headerlink" title="2.3 Gnome 桌面优化"></a>2.3 Gnome 桌面优化</h3><ul><li><code>sudo dnf install gnome-tweaks gnome-extensions-app</code></li></ul><blockquote><p><a href="https://fjqz177.top/posts/9/">引用文章</a></p></blockquote><h2 id="3-Raspberry-Pi"><a href="#3-Raspberry-Pi" class="headerlink" title="3 Raspberry Pi"></a>3 Raspberry Pi</h2><h3 id="3-1-树莓派-UART-连接"><a href="#3-1-树莓派-UART-连接" class="headerlink" title="3.1 树莓派 UART 连接"></a>3.1 树莓派 UART 连接</h3><p>树莓派自带的 UART 针脚图：</p><p><img src="/posts/28f0e3d2/e85f34a0ba92a9c9510a503ba7aa6527_MD5.jpeg"></p><h3 id="3-2-使用命令连接-WIFI"><a href="#3-2-使用命令连接-WIFI" class="headerlink" title="3.2 使用命令连接 WIFI"></a>3.2 使用命令连接 WIFI</h3><p>使用 UART 连接到树莓派并登录进系统。</p><p>使用 <code>sudo nmcli dev wifi list</code> 命令查看 wifi 列表（前提树莓派的 WiFi 功能已启用，如果未启用使用 <code>sudo raspi-config</code> 进行配置）。</p><p><img src="/posts/28f0e3d2/dd34d0739b45cf7c2a5cf805866517d1_MD5.jpeg"></p><p><code>sudo nmcli dev wifi connect WiFi_name password WiFi_pwd</code> 连接 WiFi，例如 <code>sudo nmcli dev wifi connect ChinaNet_ABCD password 12345678</code> ，稍等片刻，连接成功！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>gcc学习笔记1</title>
    <link href="/posts/4e3171ca/"/>
    <url>/posts/4e3171ca/</url>
    
    <content type="html"><![CDATA[<blockquote><p>此文章是 gcc 学习笔记，<a href="https://www.bilibili.com/video/BV1Y8411M7fp/?p=3&spm_id_from=pageDriver&vd_source=d28f6fad4261fe5abca485f4a556dbc1">学习视频</a></p></blockquote><h2 id="1-多文件编译"><a href="#1-多文件编译" class="headerlink" title="1 多文件编译"></a>1 多文件编译</h2><p>目录结构如下：</p><p><img src="/posts/4e3171ca/fc81ec4f3b390a718d9f921c56e31774_MD5.jpeg"></p><p><code>main.c</code>（主程序）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hello.h&quot;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        hello(<span class="hljs-string">&quot;呵呵，ojbk&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>hello.h</code>（函数的声明）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span>;<br></code></pre></td></tr></table></figure><p><code>hello.c</code>（函数的实现）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hello.h&quot;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span><br>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>gcc -Wall main.c hello.c -o hehe</code> 命令进行多文件编译：</p><p><img src="/posts/4e3171ca/8af5eedd71c05782187f5b0b01ad29ca_MD5.jpeg"></p><h3 id="1-1-hello-h"><a href="#1-1-hello-h" class="headerlink" title="1.1 hello.h"></a>1.1 <code>hello.h</code></h3><p>在文件目录中有 <code>hello.c</code>、<code>hello.h</code> 和 <code>main.c</code>，但是在使用 <code>gcc</code> 编译时没有包含 <code>hello.h</code></p><p>在 <code>main.c</code> 中的第二行 include 了 <code>hello.h</code>，<code>gcc -Wall main.c hello.c -o hehe</code> 在执行这条命令时，gcc 读取到 <code>main.c</code> 源文件中的第二行，就会去找 <code>hello.h</code> 文件自动包含进来，所以不用包含头文件。</p><h4 id="1-1-1-和"><a href="#1-1-1-和" class="headerlink" title="1.1.1 &quot; &quot; 和 &lt; &gt;"></a>1.1.1 <code>&quot; &quot;</code> 和 <code>&lt; &gt;</code></h4><p>在 <code>main.c</code> 中使用了 <code>include &lt;stdio.h&gt;</code> 和 <code>include &quot;hello.h&quot;</code>，这两种不同的包含符号有什么区别？</p><p><code>&quot; &quot;</code> 表示编译器首先会到当前路径（被编译的源文件所在的路径）下搜索这个头文件，找不到再去<strong>系统头文件目录</strong>。</p><p>而 <code>&lt; &gt;</code> 是直接去<strong>系统头文件目录</strong>下搜索头文件。</p><blockquote><p>头文件目录（对于 Linux 系统）<br>&#x2F;usr&#x2F;include：系统上的标准头文件目录<br>&#x2F;usr&#x2F;local&#x2F;include: 本地安装的软件包可能会将头文件放置在这个目录中</p></blockquote><h3 id="1-2-另外"><a href="#1-2-另外" class="headerlink" title="1.2 另外"></a>1.2 另外</h3><p>在上述源文件中，<code>hello.c</code> 中的 <code>include &quot;hello.h&quot;</code> 可以删除，使用 <code>gcc -Wall main.c hello.c -o hehe</code> 编译时没有任何问题，为什么？</p><p>当 <code>main.c</code> 中包含了 <code>hello.h</code> 头文件时，这个头文件中的声明 <code>void hello(const char* str);</code> 告诉编译器有一个名为 <code>hello</code> 的函数，但是并没有提供该函数的具体实现。具体的实现在 <code>hello.c</code> 文件中。</p><p>编译器在编译 <code>main.c</code> 时，会查看 <code>#include &quot;hello.h&quot;</code>，这会将 <code>hello.h</code> 文件的内容插入到 <code>main.c</code> 中。然后编译器会在 <code>main.c</code> 中找到函数声明 <code>void hello(const char* str);</code>。由于这只是一个声明，编译器并不知道函数的具体实现。</p><p><strong>当你最后执行链接阶段（使用 <code>gcc main.c hello.c -o hello</code>）时，编译器会查找 <code>hello</code> 函数的实现。</strong> 这时，编译器看到了 <code>main.c</code> 中的调用 <code>hello(&quot;呵呵，ojbk&quot;);</code>，然后会在整个工程中搜索包含了 <code>hello</code> 函数实现的文件。<strong>由于你同时编译了 <code>hello.c</code>，所以编译器找到了 <code>hello</code> 函数的实现。</strong> —— <em>正是因为同时将 <code>main.c</code> 和 <code>hello.c</code> 放在一起编译（<code>gcc main.c hello.c -o hello</code>）所以才不报错。</em></p><p>最终，链接器将 <code>main.o</code> 和 <code>hello.o</code> 这两个目标文件合并，生成了可执行文件 <code>hello</code>。</p>]]></content>
    
    
    <categories>
      
      <category>gcc学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GNU</tag>
      
      <tag>GCC</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>frp内网穿透--使用记录</title>
    <link href="/posts/75cc0c49/"/>
    <url>/posts/75cc0c49/</url>
    
    <content type="html"><![CDATA[<blockquote><p>使用内网穿透进行远程 ssh 访问</p></blockquote><p>如果A、B电脑不在同一局域网的情况下，并且都没有公网IP，A、B之间要想访问就需要内网穿透了</p><p>一种方案是购买服务商提供的内网穿透工具，如 cpolar：</p><p><img src="/posts/75cc0c49/3c199aac7cbfd9da40b7b055fc837520_MD5.jpeg"></p><p>固定端口号套餐149&#x2F;年，不用折腾。</p><p>另一种方案是购买一个有公网 IP 的服务器做“桥梁”，但是最低配的轻量应用服务器价格都在一百左右，不是特别划算。最近年底腾讯云和阿里云活动，入门的轻量应用服务器价格60几块，果断入手~~~</p><p><img src="/posts/75cc0c49/114f2d6e1fe7bfce68d305524913e43c_MD5.jpeg"></p><h2 id="1-事先准备"><a href="#1-事先准备" class="headerlink" title="1 事先准备"></a>1 事先准备</h2><ul><li>具有公网 IP 的服务器(ubuntu) —— 👌</li><li>发起访问的电脑(windows) —— 👌</li><li>被访问的电脑(Ubuntu) —— 👌</li></ul><h2 id="2-下载-frp"><a href="#2-下载-frp" class="headerlink" title="2 下载 frp"></a>2 下载 frp</h2><p>frp GitHub 项目地址： <a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p><p><img src="/posts/75cc0c49/833eaec4fe82ab68b6b75e32e30e49ea_MD5.jpeg"></p><p>分别针对 <code>具有公网IP的服务器</code> 和 <code>被访问的电脑</code> 下载相应的 frp 系统版本。我这里的两个主机都是 Ubuntu 系统，所以下载 <code>frp_0.53.2_linux_amd64.tar.gz</code> 到两个主机上，<em>注意：每个主机上都有一个相同版本的 <code>frp_0.53.2_linux_amd64.tar.gz</code>。</em></p><p>解压后，对于 <code>具有公网IP的服务器</code> 使用的是 frps (frp server)：</p><p><img src="/posts/75cc0c49/5ee686c92f4042c799cc21d7b58e6761_MD5.jpeg"></p><p>对于 <code>被访问的电脑</code> 使用的是 frpc (frp client)：</p><p><img src="/posts/75cc0c49/6ab1a7e48358d10033cd8c100bee4dbb_MD5.jpeg"></p><h2 id="3-修改-frp-配置文件"><a href="#3-修改-frp-配置文件" class="headerlink" title="3 修改 frp 配置文件"></a>3 修改 frp 配置文件</h2><h3 id="3-1-具有公网IP的服务器-的-frps-toml"><a href="#3-1-具有公网IP的服务器-的-frps-toml" class="headerlink" title="3.1 具有公网IP的服务器 的 frps.toml"></a>3.1 <code>具有公网IP的服务器</code> 的 <code>frps.toml</code></h3><p><img src="/posts/75cc0c49/afd713590a8abd299f012d8d7932c42d_MD5.jpeg"></p><p>默认的就行~</p><h3 id="3-2-被访问的电脑-的-frpc-toml"><a href="#3-2-被访问的电脑-的-frpc-toml" class="headerlink" title="3.2 被访问的电脑 的 frpc.toml"></a>3.2 <code>被访问的电脑</code> 的 <code>frpc.toml</code></h3><p><img src="/posts/75cc0c49/b53fa024875ecaa01d19bbf7c1ed6e0e_MD5.jpeg"></p><ul><li><code>serverAddr</code>：修改为 <code>具有公网IP的服务器</code> 的 IP</li><li><code>name</code>：随意填</li><li><code>type</code>：ssh 访问填 <strong>tcp</strong> </li><li><code>remotePort</code>：默认的 6000 就行</li></ul><p><img src="/posts/75cc0c49/cb48e711cc8de269bbc0f3592df21c0a_MD5.jpeg"></p><h2 id="4-设置开机自启"><a href="#4-设置开机自启" class="headerlink" title="4 设置开机自启"></a>4 设置开机自启</h2><p>使用 <code>frps -c frps.toml</code>、<code>frpc -c frpc.toml</code> 来运行 frp 服务。但是每次开机后都要在两台主机上分别运行 frp 服务，比较麻烦。使用 systemd 来实现 frp 服务的开机自启。</p><p>分别在 <code>具有公网IP的服务器</code> 和 <code>被访问的电脑</code> 的主机上使用 systemd 配置各自的 frp 开机自启服务。</p><h3 id="4-1-具有公网IP的服务器-的-frps-service"><a href="#4-1-具有公网IP的服务器-的-frps-service" class="headerlink" title="4.1 具有公网IP的服务器 的 frps.service"></a>4.1 <code>具有公网IP的服务器</code> 的 <code>frps.service</code></h3><p><code>sudo vim /etc/systemd/system/frps.service</code></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs txt">[Unit]<br>Description=frp server<br>After=network.target network-online.target syslog.target<br>Wants=network.target <br><br>[Service]<br>Type=simple<br>Restart=on-failure<br>RestartSec=5<br>ExecStart=/你的路径/frps -c /你的路径/frps.toml<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><blockquote><p>只需要针对你的路径修改 [Service] 下的 <code>ExecStart</code>，其余的不用修改</p></blockquote><p>然后运行 <code>sudo systemctl daemon-reload</code> 和 <code>sudo systemctl enable --now frps.service</code> 以启用 frps 开机自启。</p><h3 id="4-2-被访问的电脑-的-frpc-service"><a href="#4-2-被访问的电脑-的-frpc-service" class="headerlink" title="4.2 被访问的电脑 的 frpc.service"></a>4.2 <code>被访问的电脑</code> 的 <code>frpc.service</code></h3><p><code>sudo vim /etc/systemd/system/frpc.service</code></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs txt">[Unit]<br>Description=frp client <br>After=network.target network-online.target syslog.target<br>Wants=network.target <br><br>[Service]<br>Type=simple<br>Restart=on-failure<br>RestartSec=5<br>ExecStart=/你的路径/frpc -c /你的路径/frpc.toml<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><blockquote><p>只需要针对你的路径修改 [Service] 下的 <code>ExecStart</code></p></blockquote><p>然后运行 <code>sudo systemctl daemon-reload</code> 和 <code>sudo systemctl enable --now frpc.service</code> 以启用 frpc 开机自启。</p><h2 id="5-添加端口规则"><a href="#5-添加端口规则" class="headerlink" title="5 添加端口规则"></a>5 添加端口规则</h2><p>需要在 <code>具有公网IP的服务器</code> 的控制台防火墙里放行 6000、7000 端口：</p><p><img src="/posts/75cc0c49/38e6254556ea3130f974c07fc9701bbe_MD5.jpeg"></p><h2 id="6-登录使用"><a href="#6-登录使用" class="headerlink" title="6 登录使用"></a>6 登录使用</h2><p>在 <code>发起访问的电脑</code> 端远程 ssh 访问 <code>被访问的电脑</code> 端。</p><p>在 <code>发起访问的电脑</code> 端使用 ssh 工具登录 <code>具有公网IP的服务器</code> 。<strong>注意：登录地址是你购买的服务器的 IP，用户名是 <code>被访问的电脑</code> 端的用户名，密码是 <code>被访问的电脑</code> 端的密码，端口是 <code>6000</code> 。</strong></p><p>例如：</p><p><img src="/posts/75cc0c49/36ec4a0fd428863e0efeee2536b28cde_MD5.jpeg"></p><h3 id="6-1-VSCode-登录配置"><a href="#6-1-VSCode-登录配置" class="headerlink" title="6.1 VSCode 登录配置"></a>6.1 VSCode 登录配置</h3><p>捣鼓了好久才登录成功，配置如下：</p><p><img src="/posts/75cc0c49/568232814519855e8cadd299ddcff3e2_MD5.jpeg"></p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>最近 fedora40 发布了，想装个试一下。在按照此篇教程重新配置 frpc 的时候出现了一些问题。</p><p>在设置好守护进程后，frpc 并没有正常运行，使用 <code>sudo systemctl status frpc.services</code> 看到 <code>(code=exited, status=203/EXEC)</code> 的错误，网上查了一下是 SELinux 的原因，需要将 SELinux 关闭。</p><p>还有一种办法不用关闭 SELinux ：</p><ul><li>移动 <code>frpc</code> 到 <code>/usr/local/bin/</code> 下，然后再运行 <code>restorecon -Rv /usr/local/bin</code></li></ul><p>最终解决问题！</p><blockquote><p><a href="https://blog.csdn.net/FaceThePast/article/details/133793704?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-133793704-blog-135368044.235%5Ev43%5Epc_blog_bottom_relevance_base7&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-133793704-blog-135368044.235%5Ev43%5Epc_blog_bottom_relevance_base7&utm_relevant_index=1">解决办法文章</a> 、<a href="https://unix.stackexchange.com/questions/664811/systemd-service-failing-with-exit-code-status-203-exec">解决办法文章1</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>DIY</category>
      
    </categories>
    
    
    <tags>
      
      <tag>frp</tag>
      
      <tag>内网穿透</tag>
      
      <tag>ssh</tag>
      
      <tag>systemd</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
